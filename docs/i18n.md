---
title: Next.js 快速入门（应用路由）
subtitle: 如何将 Lingo.dev 编译器与 Next.js（应用路由）结合使用
---

## 简介

**Lingo.dev Compiler** 是一款由 AI 驱动的工具，可以在不更改现有组件的情况下对基于 React 的应用程序进行本地化。您只需配置一些内容，将您的应用程序包装在上下文提供程序中，就完成了——您的应用程序已实现本地化。

本指南将解释如何将 **Lingo.dev Compiler** 与 Next.js 配合使用，Next.js 是一个用于构建 Web 应用程序的全栈 React 框架。

## 您将学习的内容

- 如何在 Next.js 项目中初始化 **Lingo.dev Compiler**
- 如何配置编译器以兼容 Next.js
- 如何设置语言切换器以在不同语言环境之间切换

## 第 1 步：设置 API 密钥

**Lingo.dev Compiler** 使用大型语言模型（LLM）通过 AI 对应用程序进行本地化。要使用这些模型之一，您需要从支持的提供商处获取 API 密钥。

为了尽快开始使用，我们推荐使用 **Lingo.dev Engine**——我们自己的托管平台，提供每月 10,000 个免费使用的令牌。

设置 API 密钥的步骤：

1. [登录 Lingo.dev Engine](/auth)。
2. 导航到 **Projects** 页面。
3. 点击 **API key > Copy**。
4. 将 API 密钥存储在环境变量中：

   ```bash
   export LINGODOTDEV_API_KEY="<your_api_key>"
   ```

### 替代方案：自定义 LLM 提供商

您不必使用 **Lingo.dev Engine**。您可以配置编译器与多个自定义 LLM 提供商集成，包括：

- Groq
- Google
- Mistral
- Ollama
- OpenRouter

## 第 2 步：安装软件包

**Lingo.dev Compiler** 作为 `lingo.dev` npm 软件包的一部分分发。要安装它，请使用您喜欢的包管理器：

```bash
npm install lingo.dev
```

## 第 3 步：初始化编译器

**Lingo.dev 编译器** 集成了 [Next.js](https://nextjs.org/)，并在构建时运行。要接入构建流程，请对 `next.config.ts` 文件进行以下更改：

1. 导入编译器：

   ```ts
   import lingoCompiler from "lingo.dev/compiler";
   ```

2. 使用 `next` 方法初始化编译器：

   ```tsx
   const withLingo = lingoCompiler.next({
     sourceRoot: "app",
     lingoDir: "lingo",
     sourceLocale: "en",
     targetLocales: ["es"],
     rsc: true,
     useDirective: false,
     debug: false,
     models: "lingo.dev",
   });
   ```

   对于 Next.js App Router，请确保：

   - `sourceRoot` 设置为 `"app"`
   - `rsc` 设置为 `true`

   要了解更多可用选项，请参阅 [编译器选项](/compiler/compiler-options)。

3. 将编译器配置与现有配置合并并导出：

   ```ts
   export default withLingo(config);
   ```

完成此配置后，**Lingo.dev 编译器** 将：

- 遍历代码库的抽象语法树 (AST)
- 查找可本地化的内容（例如 JSX 元素中的文本和某些属性值）
- 使用配置的 AI 模型生成翻译
- 将原始内容和翻译内容存储在 `dictionary.js` 文件中
- 用占位符替换本地化内容

## 第 4 步：加载本地化内容

在编译器处理您的应用并生成翻译后，您需要加载并向用户提供这些本地化内容。这包括：

- 根据用户的语言偏好加载相应的字典
- 通过上下文提供器将加载的翻译提供给您的应用

在 `app/layout.tsx` 文件中，将应用包裹在 `LingoProvider` 组件中，并将 `loadDictionary` 函数传递给它：

```tsx
import { LingoProvider, loadDictionary } from "lingo.dev/react/rsc";

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <LingoProvider loadDictionary={(locale) => loadDictionary(locale)}>
      <html lang="en">
        <body>{children}</body>
      </html>
    </LingoProvider>
  );
}
```

`loadDictionary` 函数：

- 从 `lingo-locale` cookie 中检索当前语言（默认为 `"en"`）
- 从 `dictionary.js` 文件中加载本地化内容

`LingoProvider` 组件是一个 React 上下文提供器，用于将编译器创建的占位符替换为本地化内容。

## 第 5 步：设置语言切换器

为了让用户能够在不同语言环境之间切换，请从 `lingo.dev` 包中导入 `LocaleSwitcher`。这是一个未添加样式的组件，其功能包括：

- 渲染一个可用语言环境的下拉菜单
- 允许用户选择语言环境
- 记住用户选择的语言环境以便下次访问

要使用该组件，只需将其嵌入到应用程序中的任意位置，并将 `locales` 属性设置为包含已配置的源语言和目标语言的数组：

```tsx
import { LocaleSwitcher } from "lingo.dev/react/client";

<LocaleSwitcher locales={["en", "es"]} />;
```

### 替代方案：自定义语言切换器

您不必使用 `LocaleSwitcher` 组件。您可以实现自定义的语言切换逻辑和用户界面。唯一的要求是将当前活动的语言环境读写到 `lingo-locale` cookie 中。

## 第 6 步：运行应用程序

要验证 **Lingo.dev Compiler** 是否已正确设置：

1. 启动开发服务器：

   ```bash
   npm run dev
   ```

2. 访问 [localhost:3000](http://localhost:3000)。
3. 使用 `LocaleSwitcher` 组件在不同语言环境之间切换。

页面应重新加载并显示本地化的内容。

### 替代方案：手动设置 Cookie

如果您不使用 `LocaleSwitcher` 组件，另一种验证本地化是否正常工作的方式是手动设置 `lingo-locale` cookie。

如果您使用的是 Google Chrome，请按照以下步骤操作：

1. 导航到 **查看 > 开发者 > 开发者工具**。
2. 转到 **应用程序** 选项卡。
3. 在左侧边栏的 **存储** 下，展开 **Cookies** 并选择站点的 URL。
4. 在 cookies 表格中，右键单击任意位置并选择 **添加**。
5. 在 **名称** 列中，输入 `lingo-locale`。
6. 在 **值** 列中，输入所需的语言环境（例如，`es`）。
7. 按 **Enter** 保存 cookie。
8. 刷新页面以应用 cookie。


# 本地化

此项目使用 Lingo.dev Compiler 进行本地化。

Lingo.dev Compiler 是一个针对基于 React 应用的尖端本地化工具。

## 警告！

- Lingo.dev Compiler 与其他本地化工具完全不同。
- 您绝不能对 Lingo.dev Compiler 的工作方式做出假设。
- 如果您做出假设，用户的应用程序将会崩溃。

## 工作原理

与许多其他本地化工具不同，Lingo.dev Compiler：

- 遍历应用程序源代码的抽象语法树 (AST)
- 确定性地提取可本地化内容
- 使用大型语言模型自动本地化内容

## 不支持的功能

与许多其他本地化工具不同，Lingo.dev Compiler 不支持以下功能：

- 任何形式的 `useTranslation` 钩子（或类似功能）
- 任何形式的 `FormattedMessage` 组件（或类似功能）
- 任何形式的 `localizeText` 方法（或类似功能）

这些功能与 Lingo.dev Compiler 的整个目的、理念和行为完全相悖。

您必须始终仔细理解并考虑这些与其他工具的根本区别。

## 支持的文件扩展名

这些规则仅适用于 `.jsx` 和 `.tsx` 扩展名的文件。

不具有这些扩展名的文件对 Lingo.dev Compiler 是不可见的，因此不在范围内。

## 自动生成的文件

在构建时，Lingo.dev Compiler 会自动生成以下文件：

- `meta.json`（用于存储提取的内容）
- `dictionary.js`（用于存储翻译的内容）

您不得编辑这些文件。您可以出于调试目的阅读它们并向用户解释，但仅限于此。

## 职责

您有以下职责：

- 确保应本地化的内容处于可本地化的格式。
- 确保不应本地化的内容处于不可本地化的格式。
- 帮助用户理解内容为何（或为何不）被本地化。

仅此而已。

Lingo.dev Compiler 将处理其他所有事情。不要妨碍它的工作。

## 可本地化的内容

本节列出了 Lingo.dev 编译器提取和本地化的内容类型。

此列表是详尽无遗的。如果某种内容类型未在此列出，请假定它不可本地化。

### JSX 元素

```tsx
import React from "react";

export function App() {
  return <div>此文本将被本地化。</div>;
}
```

### JSX 片段

#### 语法 1

```tsx
import React from "react";

export function App() {
  return <React.Fragment>此文本将被本地化。</React.Fragment>;
}
```

#### 语法 2

```tsx
import { Fragment } from "react";

export function App() {
  return <Fragment>此文本将被本地化。</Fragment>;
}
```

#### 语法 3

```tsx
import React from "react";

export function App() {
  return <>此文本将被本地化。</>;
}
```

### 条件元素或片段

```tsx
import React, { Fragment, useState } from "react";

export function App() {
  const [isVisible, setIsVisible] = useState(false);

  return (
    <>
      {isVisible && <div>此文本将被本地化。</div>}
      {isVisible && (
        <React.Fragment>此文本将被本地化。</React.Fragment>
      )}
      {isVisible && <Fragment>此文本将被本地化。</Fragment>}
      {isVisible && <>此文本将被本地化。</>}
    </>
  );
}
```

### `alt` 属性值

```tsx
import React from "react";

export function App() {
  return <img src="/logo.png" alt="此文本将被本地化" />;
}
```

### `aria-label` 属性值

```tsx
import React from "react";

export function App() {
  return <button aria-label="此文本将被本地化">×</button>;
}
```

### `label` 属性值

```tsx
import React from "react";

export function App() {
  return (
    <select>
      <option value="option1" label="此文本将被本地化">
        此文本将被本地化
      </option>
      <option value="option2" label="此文本将被本地化">
        此文本将被本地化
      </option>
    </select>
  );
}
```

### `placeholder` 属性值

```tsx
import React from "react";

export function App() {
  return <input placeholder="此文本将被本地化" />;
}
```

### `title` 属性值

```tsx
import React from "react";

export function App() {
  return <button title="此文本将被本地化">提交</button>;
}
```

## 不可本地化的内容

本节列出了 Lingo.dev 编译器不会提取或本地化的内容类型。

与“可本地化内容”列表不同，此列表并不详尽。

### `data-` 属性

```tsx
import React from "react";

export function App() {
  return <div data-testid="此文本不会被本地化">内容</div>;
}
```

### 字符串字面量

```tsx
import React from "react";

const exampleText = "此文本不会被本地化。";

export function App() {
  return <div>{exampleText}</div>;
}
```

### 模板字符串

```tsx
import React from "react";

const exampleText = `此文本不会被本地化。`;

export function App() {
  return <div>{exampleText}</div>;
}
```

### 条件字符串

```tsx
import { Fragment, useState } from "react";

export function App() {
  const [isVisible, setIsVisible] = useState(false);

  return <>{isVisible && "此文本不会被本地化。"}</>;
}
```

## 限制

- 不要自行本地化内容。
- 不要显式加载本地化内容到应用中。
- 不要臆造 React hooks（例如，`useTranslation`）。
- 不要臆造 React 组件（例如，`FormattedMessage`）。
- 不要臆造方法（例如，`localizeText`）。


---

title: '"use i18n";'
---

**"use i18n" 指令**使 React 组件的文件级本地化成为可能，无需重构现有代码。就像 `"use client"` 或 `"use server"` 一样，您只需将其添加到文件顶部，即可自动本地化该组件中所有可翻译的内容。

这种方法非常适合在大型代码库中逐步添加多语言支持，风险最小且灵活性最大。

## 工作原理

当您将 `"use i18n"` 添加到 React 文件顶部时，**Lingo.dev 编译器**会自动：

1. **扫描整个文件**以查找可翻译内容
2. **提取 JSX 文本**和可翻译属性
3. **使用您配置的 AI 模型生成翻译**
4. **在构建时注入本地化版本**
5. **保持热模块替换**以实现无缝开发

该指令在文件级别工作，处理该组件边界内的所有内容，同时保持应用程序的其余部分不变。

## 启用指令

要使用 `"use i18n"` 指令，请在编译器配置中启用它：

```js
{
  sourceLocale: "en",
  targetLocales: ["es", "fr", "de"],
  useDirective: true, // 启用 "use i18n" 指令
  models: "lingo.dev", // 选项 1：Lingo.dev 引擎
  // models: {
  //   "*:*": "groq:qwen/qwen3-32b", // 选项 2：GROQ
  //   "*:*": "google:gemini-2.0-flash", // 选项 2：Google AI
  //   "*:*": "openrouter:mistralai/mistral-small-24b-instruct-2501", // 选项 2：OpenRouter
  //   "*:*": "ollama:mistral-small3.1", // 选项 2：Ollama
  //   "*:*": "mistral:mistral-small-latest", // Mistral
  // },
}
```

**注意：** 当 `useDirective` 设置为 `false`（默认值）时，**Lingo.dev 编译器**会将所有文件视为其顶部已包含 `"use i18n"`。设置 `useDirective: true` 可让您对文件的本地化进行精细控制。

**模型配置：** 您可以使用 [Lingo.dev 引擎](/compiler/how-it-works#option-1-lingodev-engine) 的简化语法（`models: "lingo.dev"`），或使用 [其他 LLM 提供商](/compiler/how-it-works#option-2-alternative-llm-providers) 的模型并进行特定模型映射（例如，`models: { "*:*": "groq:qwen/qwen3-32b" }`，详见上文）。引擎会自动为每种语言对选择最佳模型。

## 基本用法

在任何 React 组件文件的顶部添加指令：

```tsx
"use i18n";

import React from "react";

export function WelcomeCard() {
  return (
    <div className="card">
      <h2>欢迎使用我们的应用！</h2>
      <p>
        开始探索我们的功能，发现让我们平台与众不同的地方。
      </p>
      <button>开始使用</button>
    </div>
  );
}
```

**注意：** 在渲染 `<LingoProvider>` 的文件顶部添加 "use i18n"。

就是这样！组件现在将自动以用户选择的语言渲染，无需任何代码更改。

## 与现有指令兼容

`"use i18n"` 指令可以自然地与您可能已经使用的其他 React 指令一起工作：

```tsx
"use client";
"use i18n";

export function InteractiveComponent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>点击计数器</h1>
      <p>您已点击 {count} 次</p>
      <button onClick={() => setCount(count + 1)}>点击我！</button>
    </div>
  );
}
```

```tsx
"use server";
"use i18n";

export async function ServerComponent() {
  const data = await fetchData();

  return (
    <div>
      <h1>服务器渲染内容</h1>
      <p>此内容在服务器上渲染，并在构建时本地化</p>
    </div>
  );
}
```

编译器会智能地处理所有指令，保持组件的预期行为，同时添加本地化功能。

## 开发工作流程

### 1. 渐进式迁移

从为单个组件添加指令开始：

```tsx
// 之前：仅支持英文的组件
export function Header() {
  return <h1>我的应用</h1>;
}

// 之后：通过一行代码实现多语言支持的组件
("use i18n");

export function Header() {
  return <h1>我的应用</h1>;
}
```

### 2. 热模块替换

该指令与 HMR 无缝集成。当您修改带有 `"use i18n"` 的组件中的文本时，翻译会立即在浏览器中更新：

```tsx
"use i18n";

export function StatusMessage() {
  return (
    <div>
      {/* 修改此文本，立即在所有语言中更新 */}
      <p>您的更改已成功保存！</p>
    </div>
  );
}
```

### 3. 按文件逐步处理的方法

非常适合需要逐步本地化的大型代码库：

```text
src/
├── components/
│   ├── Header.tsx          // ✅ "use i18n" - 已本地化
│   ├── Navigation.tsx      // ✅ "use i18n" - 已本地化
│   ├── ProductCard.tsx     // ✅ "use i18n" - 已本地化
│   ├── Footer.tsx          // ⏳ 尚未本地化
│   └── Sidebar.tsx         // ⏳ 尚未本地化
```

## 优势

`"use i18n"` 指令使本地化变得像在 React 组件中添加一行代码一样简单，专为需要逐步本地化的成熟项目设计。
