---
title: Next.js 快速入门（应用路由）
subtitle: 如何将 Lingo.dev 编译器与 Next.js（应用路由）结合使用
---

## 简介

**Lingo.dev Compiler** 是一款由 AI 驱动的工具，可以在不更改现有组件的情况下对基于 React 的应用程序进行本地化。您只需配置一些内容，将您的应用程序包装在上下文提供程序中，就完成了——您的应用程序已实现本地化。

本指南将解释如何将 **Lingo.dev Compiler** 与 Next.js 配合使用，Next.js 是一个用于构建 Web 应用程序的全栈 React 框架。

## 您将学习的内容

- 如何在 Next.js 项目中初始化 **Lingo.dev Compiler**
- 如何配置编译器以兼容 Next.js
- 如何设置语言切换器以在不同语言环境之间切换

## 第 1 步：设置 API 密钥

**Lingo.dev Compiler** 使用大型语言模型（LLM）通过 AI 对应用程序进行本地化。要使用这些模型之一，您需要从支持的提供商处获取 API 密钥。

为了尽快开始使用，我们推荐使用 **Lingo.dev Engine**——我们自己的托管平台，提供每月 10,000 个免费使用的令牌。

设置 API 密钥的步骤：

1. [登录 Lingo.dev Engine](/auth)。
2. 导航到 **Projects** 页面。
3. 点击 **API key > Copy**。
4. 将 API 密钥存储在环境变量中：

   ```bash
   export LINGODOTDEV_API_KEY="<your_api_key>"
   ```

### 替代方案：自定义 LLM 提供商

您不必使用 **Lingo.dev Engine**。您可以配置编译器与多个自定义 LLM 提供商集成，包括：

- Groq
- Google
- Mistral
- Ollama
- OpenRouter

## 第 2 步：安装软件包

**Lingo.dev Compiler** 作为 `lingo.dev` npm 软件包的一部分分发。要安装它，请使用您喜欢的包管理器：

```bash
npm install lingo.dev
```

## 第 3 步：初始化编译器

**Lingo.dev 编译器** 集成了 [Next.js](https://nextjs.org/)，并在构建时运行。要接入构建流程，请对 `next.config.ts` 文件进行以下更改：

1. 导入编译器：

   ```ts
   import lingoCompiler from "lingo.dev/compiler";
   ```

2. 使用 `next` 方法初始化编译器：

   ```tsx
   const withLingo = lingoCompiler.next({
     sourceRoot: "app",
     lingoDir: "lingo",
     sourceLocale: "en",
     targetLocales: ["es"],
     rsc: true,
     useDirective: false,
     debug: false,
     models: "lingo.dev",
   });
   ```

   对于 Next.js App Router，请确保：

   - `sourceRoot` 设置为 `"app"`
   - `rsc` 设置为 `true`

   要了解更多可用选项，请参阅 [编译器选项](/compiler/compiler-options)。

3. 将编译器配置与现有配置合并并导出：

   ```ts
   export default withLingo(config);
   ```

完成此配置后，**Lingo.dev 编译器** 将：

- 遍历代码库的抽象语法树 (AST)
- 查找可本地化的内容（例如 JSX 元素中的文本和某些属性值）
- 使用配置的 AI 模型生成翻译
- 将原始内容和翻译内容存储在 `dictionary.js` 文件中
- 用占位符替换本地化内容

## 第 4 步：加载本地化内容

在编译器处理您的应用并生成翻译后，您需要加载并向用户提供这些本地化内容。这包括：

- 根据用户的语言偏好加载相应的字典
- 通过上下文提供器将加载的翻译提供给您的应用

在 `app/layout.tsx` 文件中，将应用包裹在 `LingoProvider` 组件中，并将 `loadDictionary` 函数传递给它：

```tsx
import { LingoProvider, loadDictionary } from "lingo.dev/react/rsc";

export default function RootLayout({
  children,
}: Readonly<{ children: React.ReactNode }>) {
  return (
    <LingoProvider loadDictionary={(locale) => loadDictionary(locale)}>
      <html lang="en">
        <body>{children}</body>
      </html>
    </LingoProvider>
  );
}
```

`loadDictionary` 函数：

- 从 `lingo-locale` cookie 中检索当前语言（默认为 `"en"`）
- 从 `dictionary.js` 文件中加载本地化内容

`LingoProvider` 组件是一个 React 上下文提供器，用于将编译器创建的占位符替换为本地化内容。

## 第 5 步：设置语言切换器

为了让用户能够在不同语言环境之间切换，请从 `lingo.dev` 包中导入 `LocaleSwitcher`。这是一个未添加样式的组件，其功能包括：

- 渲染一个可用语言环境的下拉菜单
- 允许用户选择语言环境
- 记住用户选择的语言环境以便下次访问

要使用该组件，只需将其嵌入到应用程序中的任意位置，并将 `locales` 属性设置为包含已配置的源语言和目标语言的数组：

```tsx
import { LocaleSwitcher } from "lingo.dev/react/client";

<LocaleSwitcher locales={["en", "es"]} />;
```

### 替代方案：自定义语言切换器

您不必使用 `LocaleSwitcher` 组件。您可以实现自定义的语言切换逻辑和用户界面。唯一的要求是将当前活动的语言环境读写到 `lingo-locale` cookie 中。

## 第 6 步：运行应用程序

要验证 **Lingo.dev Compiler** 是否已正确设置：

1. 启动开发服务器：

   ```bash
   npm run dev
   ```

2. 访问 [localhost:3000](http://localhost:3000)。
3. 使用 `LocaleSwitcher` 组件在不同语言环境之间切换。

页面应重新加载并显示本地化的内容。

### 替代方案：手动设置 Cookie

如果您不使用 `LocaleSwitcher` 组件，另一种验证本地化是否正常工作的方式是手动设置 `lingo-locale` cookie。

如果您使用的是 Google Chrome，请按照以下步骤操作：

1. 导航到 **查看 > 开发者 > 开发者工具**。
2. 转到 **应用程序** 选项卡。
3. 在左侧边栏的 **存储** 下，展开 **Cookies** 并选择站点的 URL。
4. 在 cookies 表格中，右键单击任意位置并选择 **添加**。
5. 在 **名称** 列中，输入 `lingo-locale`。
6. 在 **值** 列中，输入所需的语言环境（例如，`es`）。
7. 按 **Enter** 保存 cookie。
8. 刷新页面以应用 cookie。


# 本地化

此项目使用 Lingo.dev Compiler 进行本地化。

Lingo.dev Compiler 是一个针对基于 React 应用的尖端本地化工具。

## 警告！

- Lingo.dev Compiler 与其他本地化工具完全不同。
- 您绝不能对 Lingo.dev Compiler 的工作方式做出假设。
- 如果您做出假设，用户的应用程序将会崩溃。

## 工作原理

与许多其他本地化工具不同，Lingo.dev Compiler：

- 遍历应用程序源代码的抽象语法树 (AST)
- 确定性地提取可本地化内容
- 使用大型语言模型自动本地化内容

## 不支持的功能

与许多其他本地化工具不同，Lingo.dev Compiler 不支持以下功能：

- 任何形式的 `useTranslation` 钩子（或类似功能）
- 任何形式的 `FormattedMessage` 组件（或类似功能）
- 任何形式的 `localizeText` 方法（或类似功能）

这些功能与 Lingo.dev Compiler 的整个目的、理念和行为完全相悖。

您必须始终仔细理解并考虑这些与其他工具的根本区别。

## 支持的文件扩展名

这些规则仅适用于 `.jsx` 和 `.tsx` 扩展名的文件。

不具有这些扩展名的文件对 Lingo.dev Compiler 是不可见的，因此不在范围内。

## 自动生成的文件

在构建时，Lingo.dev Compiler 会自动生成以下文件：

- `meta.json`（用于存储提取的内容）
- `dictionary.js`（用于存储翻译的内容）

您不得编辑这些文件。您可以出于调试目的阅读它们并向用户解释，但仅限于此。

## 职责

您有以下职责：

- 确保应本地化的内容处于可本地化的格式。
- 确保不应本地化的内容处于不可本地化的格式。
- 帮助用户理解内容为何（或为何不）被本地化。

仅此而已。

Lingo.dev Compiler 将处理其他所有事情。不要妨碍它的工作。

## 可本地化的内容

本节列出了 Lingo.dev 编译器提取和本地化的内容类型。

此列表是详尽无遗的。如果某种内容类型未在此列出，请假定它不可本地化。

### JSX 元素

```tsx
import React from "react";

export function App() {
  return <div>此文本将被本地化。</div>;
}
```

### JSX 片段

#### 语法 1

```tsx
import React from "react";

export function App() {
  return <React.Fragment>此文本将被本地化。</React.Fragment>;
}
```

#### 语法 2

```tsx
import { Fragment } from "react";

export function App() {
  return <Fragment>此文本将被本地化。</Fragment>;
}
```

#### 语法 3

```tsx
import React from "react";

export function App() {
  return <>此文本将被本地化。</>;
}
```

### 条件元素或片段

```tsx
import React, { Fragment, useState } from "react";

export function App() {
  const [isVisible, setIsVisible] = useState(false);

  return (
    <>
      {isVisible && <div>此文本将被本地化。</div>}
      {isVisible && (
        <React.Fragment>此文本将被本地化。</React.Fragment>
      )}
      {isVisible && <Fragment>此文本将被本地化。</Fragment>}
      {isVisible && <>此文本将被本地化。</>}
    </>
  );
}
```

### `alt` 属性值

```tsx
import React from "react";

export function App() {
  return <img src="/logo.png" alt="此文本将被本地化" />;
}
```

### `aria-label` 属性值

```tsx
import React from "react";

export function App() {
  return <button aria-label="此文本将被本地化">×</button>;
}
```

### `label` 属性值

```tsx
import React from "react";

export function App() {
  return (
    <select>
      <option value="option1" label="此文本将被本地化">
        此文本将被本地化
      </option>
      <option value="option2" label="此文本将被本地化">
        此文本将被本地化
      </option>
    </select>
  );
}
```

### `placeholder` 属性值

```tsx
import React from "react";

export function App() {
  return <input placeholder="此文本将被本地化" />;
}
```

### `title` 属性值

```tsx
import React from "react";

export function App() {
  return <button title="此文本将被本地化">提交</button>;
}
```

## 不可本地化的内容

本节列出了 Lingo.dev 编译器不会提取或本地化的内容类型。

与“可本地化内容”列表不同，此列表并不详尽。

### `data-` 属性

```tsx
import React from "react";

export function App() {
  return <div data-testid="此文本不会被本地化">内容</div>;
}
```

### 字符串字面量

```tsx
import React from "react";

const exampleText = "此文本不会被本地化。";

export function App() {
  return <div>{exampleText}</div>;
}
```

### 模板字符串

```tsx
import React from "react";

const exampleText = `此文本不会被本地化。`;

export function App() {
  return <div>{exampleText}</div>;
}
```

### 条件字符串

```tsx
import { Fragment, useState } from "react";

export function App() {
  const [isVisible, setIsVisible] = useState(false);

  return <>{isVisible && "此文本不会被本地化。"}</>;
}
```

## 限制

- 不要自行本地化内容。
- 不要显式加载本地化内容到应用中。
- 不要臆造 React hooks（例如，`useTranslation`）。
- 不要臆造 React 组件（例如，`FormattedMessage`）。
- 不要臆造方法（例如，`localizeText`）。


---

title: '"use i18n";'
---

**"use i18n" 指令**使 React 组件的文件级本地化成为可能，无需重构现有代码。就像 `"use client"` 或 `"use server"` 一样，您只需将其添加到文件顶部，即可自动本地化该组件中所有可翻译的内容。

这种方法非常适合在大型代码库中逐步添加多语言支持，风险最小且灵活性最大。

## 工作原理

当您将 `"use i18n"` 添加到 React 文件顶部时，**Lingo.dev 编译器**会自动：

1. **扫描整个文件**以查找可翻译内容
2. **提取 JSX 文本**和可翻译属性
3. **使用您配置的 AI 模型生成翻译**
4. **在构建时注入本地化版本**
5. **保持热模块替换**以实现无缝开发

该指令在文件级别工作，处理该组件边界内的所有内容，同时保持应用程序的其余部分不变。

## 启用指令

要使用 `"use i18n"` 指令，请在编译器配置中启用它：

```js
{
  sourceLocale: "en",
  targetLocales: ["es", "fr", "de"],
  useDirective: true, // 启用 "use i18n" 指令
  models: "lingo.dev", // 选项 1：Lingo.dev 引擎
  // models: {
  //   "*:*": "groq:qwen/qwen3-32b", // 选项 2：GROQ
  //   "*:*": "google:gemini-2.0-flash", // 选项 2：Google AI
  //   "*:*": "openrouter:mistralai/mistral-small-24b-instruct-2501", // 选项 2：OpenRouter
  //   "*:*": "ollama:mistral-small3.1", // 选项 2：Ollama
  //   "*:*": "mistral:mistral-small-latest", // Mistral
  // },
}
```

**注意：** 当 `useDirective` 设置为 `false`（默认值）时，**Lingo.dev 编译器**会将所有文件视为其顶部已包含 `"use i18n"`。设置 `useDirective: true` 可让您对文件的本地化进行精细控制。

**模型配置：** 您可以使用 [Lingo.dev 引擎](/compiler/how-it-works#option-1-lingodev-engine) 的简化语法（`models: "lingo.dev"`），或使用 [其他 LLM 提供商](/compiler/how-it-works#option-2-alternative-llm-providers) 的模型并进行特定模型映射（例如，`models: { "*:*": "groq:qwen/qwen3-32b" }`，详见上文）。引擎会自动为每种语言对选择最佳模型。

## 基本用法

在任何 React 组件文件的顶部添加指令：

```tsx
"use i18n";

import React from "react";

export function WelcomeCard() {
  return (
    <div className="card">
      <h2>欢迎使用我们的应用！</h2>
      <p>
        开始探索我们的功能，发现让我们平台与众不同的地方。
      </p>
      <button>开始使用</button>
    </div>
  );
}
```

**注意：** 在渲染 `<LingoProvider>` 的文件顶部添加 "use i18n"。

就是这样！组件现在将自动以用户选择的语言渲染，无需任何代码更改。

## 与现有指令兼容

`"use i18n"` 指令可以自然地与您可能已经使用的其他 React 指令一起工作：

```tsx
"use client";
"use i18n";

export function InteractiveComponent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <h1>点击计数器</h1>
      <p>您已点击 {count} 次</p>
      <button onClick={() => setCount(count + 1)}>点击我！</button>
    </div>
  );
}
```

```tsx
"use server";
"use i18n";

export async function ServerComponent() {
  const data = await fetchData();

  return (
    <div>
      <h1>服务器渲染内容</h1>
      <p>此内容在服务器上渲染，并在构建时本地化</p>
    </div>
  );
}
```

编译器会智能地处理所有指令，保持组件的预期行为，同时添加本地化功能。

## 开发工作流程

### 1. 渐进式迁移

从为单个组件添加指令开始：

```tsx
// 之前：仅支持英文的组件
export function Header() {
  return <h1>我的应用</h1>;
}

// 之后：通过一行代码实现多语言支持的组件
("use i18n");

export function Header() {
  return <h1>我的应用</h1>;
}
```

### 2. 热模块替换

该指令与 HMR 无缝集成。当您修改带有 `"use i18n"` 的组件中的文本时，翻译会立即在浏览器中更新：

```tsx
"use i18n";

export function StatusMessage() {
  return (
    <div>
      {/* 修改此文本，立即在所有语言中更新 */}
      <p>您的更改已成功保存！</p>
    </div>
  );
}
```

### 3. 按文件逐步处理的方法

非常适合需要逐步本地化的大型代码库：

```text
src/
├── components/
│   ├── Header.tsx          // ✅ "use i18n" - 已本地化
│   ├── Navigation.tsx      // ✅ "use i18n" - 已本地化
│   ├── ProductCard.tsx     // ✅ "use i18n" - 已本地化
│   ├── Footer.tsx          // ⏳ 尚未本地化
│   └── Sidebar.tsx         // ⏳ 尚未本地化
```

## 优势

`"use i18n"` 指令使本地化变得像在 React 组件中添加一行代码一样简单，专为需要逐步本地化的成熟项目设计。


---

title: 常见问题
---

关于 **Lingo.dev Compiler** 的常见问题和解答。

## 我可以翻译字符串字面量吗？

**Lingo.dev Compiler** 遵循的约定是，JSX 中的所有内容都是可本地化的。JSX 组件之外的字符串字面量设计上不会被本地化。

**当前行为：**

```tsx
// 这段代码不会被翻译
const message = "Hello world";
const errorText = "Something went wrong";

// 这段代码会被翻译
function Component() {
  return <h1>Hello world</h1>;
}
```

**使字面量可本地化：**

您可以通过将字符串字面量包裹在 JSX 片段中来使其可本地化：

```tsx
// 之前：不可本地化
const message = "Hello world";

// 之后：使用片段使其可本地化
const message = <>Hello world</>;

// 在组件中使用
function Component() {
  return <div>{message}</div>;
}
```

**替代方法：**

```tsx
// 对于动态消息
function getLocalizedMessage() {
  return <>Something went wrong</>;
}

// 对于条件文本
const statusText = isError ? <>Error occurred</> : <>Success</>;
```

此约定确保了本地化行为的一致性，同时保持了可本地化内容和不可本地化内容之间的清晰界限。

我们正在探索扩展此行为以支持更多用例的方法。欢迎加入我们的 [Discord](https://lingo.dev/go/discord) 讨论您希望支持的具体模式。

## 为什么我的基于集合的组件没有被翻译？

编译器目前对基于 Adobe React-Aria/React-Stately 的组件存在限制，这些组件期望集合作为子元素。集合项中的直接文本内容不会被自动本地化。

这会影响像 Select、Listbox、Menu 以及其他类似的基于集合的组件，这些组件来自 HeroUI、NextUI 和其他 React-Aria 实现的库。

**当前行为：**

```tsx
import { Select, SelectItem } from "@heroui/react";

export default function SelectExample() {
  return (
    <Select label="Select an animal">
      {/* 这些文本不会被翻译 */}
      <SelectItem key="cat" textValue="Cat">
        Cat
      </SelectItem>
      <SelectItem key="dog" textValue="Dog">
        Dog
      </SelectItem>
    </Select>
  );
}
```

**解决方法：**

将文本内容包裹在 JSX 片段中以使其可本地化：

```tsx
import { Select, SelectItem } from "@heroui/react";

export default function SelectWithWorkaround() {
  return (
    <Select label="Select an animal">
      {/* 这些文本会被翻译 */}
      <SelectItem key="cat" textValue="Cat">
        <>Cat</>
      </SelectItem>
      <SelectItem key="dog" textValue="Dog">
        <>Dog</>
      </SelectItem>
    </Select>
  );
}
```

此限制影响任何使用 React-Aria 集合模式的组件，其中文本内容直接作为子元素传递给集合项。我们正在努力改进编译器对这些情况的支持。

## 支持哪些框架？

**Lingo.dev 编译器**目前支持以下 React 框架：

- **Next.js**（仅支持 App Router）
- **React Router** v6+
- **Remix**（最新版本）
- **Vite + React**

我们欢迎对其他平台实现编译器支持感兴趣的贡献者。[加入我们的 Discord](https://lingo.dev/go/discord) 讨论实现策略。

## 我可以添加更多语言吗？

可以！您可以通过直接在编译器配置中配置自定义模型来扩展语言支持：

```ts
const compilerConfig = {
  sourceLocale: "en",
  targetLocales: ["es", "fr", "de", "pt", "it"],
  models: {
    "*:pt": "qwen/qwen3-32b",
    "en:it": "meta-llama/llama-4-maverick-17b-128e-instruct",
    "*:*": "qwen/qwen3-32b",
  },
};

lingoCompiler.next(compilerConfig)(nextConfig);
```

查看[高级配置](/compiler/configuration/advanced#custom-model-configuration)了解详细信息。

## 我可以使用自定义提示吗？

可以！您可以直接在编译器配置中自定义翻译提示：

```ts
const compilerConfig = {
  sourceLocale: "en",
  targetLocales: ["es", "fr", "de"],
  prompt:
    "您是一名专业的技术文档翻译员。从 {SOURCE_LOCALE} 翻译到 {TARGET_LOCALE}，同时保持技术准确性。",
};
```

对于自定义术语表，请在提示中包含术语定义。参考我们的[默认提示](https://github.com/lingodotdev/lingo.dev/blob/main/packages/compiler/src/lib/lcp/api/prompt.ts)以获取最佳实践。

## 我可以使用更多的 LLM 提供商吗？

目前，Lingo.dev 编译器集成了 [Lingo.dev 引擎和多个其他 LLM 提供商](/compiler/how-it-works#llm-providers)。

我们希望很快支持更多的 LLM 提供商——[联系我们](https://lingo.dev/go/discord) 或 [向我们发送拉取请求](https://github.com/lingodotdev/lingo.dev/)。

## 在 CI/CD 中需要 GROQ API 密钥吗？

通常不需要。如果您在本地构建应用程序，所有翻译将存储在 `lingo/` 目录中。您的 CI/CD 构建将不需要调用 LLM 来翻译任何字符串。

或者，您可以将 `GROQ_API_KEY` 变量添加到您的 CI/CD 中，并在构建时完成所有翻译，但我们不推荐这种方法，以便更好地控制最终翻译结果。

## 我可以编辑翻译吗？

可以！您可以手动编辑 `lingo/dictionary.js` 文件。该文件导出一个包含所有文件和条目翻译的对象。您可以在 `content` 属性中编辑每个语言的文本。只要 React 组件中的源文本未更新，您的编辑将会被保留。

**不喜欢编辑 JavaScript 对象？** 我们即将发布一个编辑器来改善编辑体验。[如果您感兴趣，请告诉我们！](https://lingo.dev/go/discord)

## 我如何重新翻译整个应用程序、特定文件或语言？

要重新翻译整个应用程序，请删除 `lingo/` 目录中的 `dictionary.js` 文件。

要仅重新翻译特定文件，您可以从 `dictionary.js` 中删除它们的键（文件名）。

如果您想重新翻译特定语言，需要删除该语言的所有记录。

## 为什么需要在本地构建应用程序？

本地构建会通过以下方式规范化您的 `lingo/` 翻译文件：

- 删除未使用的翻译键
- 更新内容指纹
- 确保文件格式一致
- 优化生产部署

在提交更改之前，请始终运行 `npm run build` 以保持翻译文件的整洁。

## 缺少翻译内容

如果缺少翻译内容：

1. **在本地构建**以规范化您的 `lingo/` 文件：

   ```bash
   npm run build
   ```

2. **检查您的 API 密钥**是否正确设置：

   ```bash
   # 确保 .env 文件包含
   GROQ_API_KEY=gsk_...
   ```

3. **提交更新的文件**：

   ```bash
   git add lingo/
   git commit -m "Update translations"
   ```

4. **在更改后重启开发服务器**。

## 我可以设置自定义术语表吗？

可以！使用自定义提示直接在编译器配置中定义术语和术语表：

```ts
const compilerConfig = {
  sourceLocale: "en",
  targetLocales: ["es", "fr", "de"],
  prompt:
    "You are a professional translator. Use these terms consistently: 'Dashboard' should be 'Tableau de bord' in French, 'Settings' should be 'Configuración' in Spanish. Translate from {SOURCE_LOCALE} to {TARGET_LOCALE}.",
};
```

## 编译器如何处理复数形式？

编译器会自动处理基本的复数模式，但对于复杂的复数规则，您可能需要相应地构建您的 JSX：

```tsx
// 编译器会正确处理此内容
<p>{count === 1 ? <>1 个项目</> : <>{count} 个项目</>}</p>
```

## 在生产环境中的性能如何？

**Lingo.dev 编译器**针对生产环境进行了优化：

- **零运行时成本** - 翻译在预编译阶段完成
- **包分割** - 仅加载活动语言环境
- **Tree shaking** - 未使用的翻译会被移除
- **CDN 友好** - 静态翻译文件高效缓存

## 我可以在 TypeScript 中使用它吗？

可以！编译器可以无缝集成到 TypeScript 项目中。所有提供的 React 组件都完全支持类型：

```tsx
import { LocaleSwitcher } from "lingo.dev/react/client";

// 完全支持 TypeScript
const locales: string[] = ["en", "es", "fr"];
<LocaleSwitcher locales={locales} />;
```

## 我如何报告错误或请求新功能？

- **GitHub 问题**: [提交问题](https://github.com/lingodotdev/lingo.dev/issues)
- **Discord 社区**: [加入我们的 Discord](https://lingo.dev/go/discord)
- **功能请求**: 使用 GitHub 讨论区提交功能提案

## 下一步

- **快速入门**: [快速入门指南](/compiler/quick-start)
- **框架集成**: [Next.js](/compiler/frameworks/nextjs-app-router), [React Router](/compiler/frameworks/react-router-v6), [Vite](/compiler/frameworks/vite-react-ts)
- **高级功能**: [配置选项](/compiler/configuration/advanced)
